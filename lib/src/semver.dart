import 'package:meta/meta.dart' show sealed;
import 'package:quiver/core.dart' show hashObjects;

/// An immutable class for storing [Semantic Versioning 2.0.0](https://semver.org/)
/// under Dart [Object].
///
/// You can either parse version by constructor or using [SemVer.parse] to parse
/// a [String] of version to [SemVer].
@sealed
class SemVer implements Comparable<SemVer> {
  /// A non-negative [int] value repersenting version's major release.
  final int major;

  /// A non-negative [int] value repersenting version's minor release.
  final int minor;

  /// A non-negative [int] value repersenting version's patch release.
  final int patch;

  /// An optional [String] label uses before general release.
  ///
  /// Since pre-release comes before general release, [SemVer] which applied
  /// this will be assumed lower than nulled one.
  final String? preRelease;

  /// An option [String] label uses for release new version that does not meeted
  /// requirement for increasing [patch] value like fixing API document.
  final String? build;

  SemVer._(this.major, this.minor, this.patch, [this.preRelease, this.build]);

  /// A basic constructor that apply [major], [minor], [patch], [preRelease]
  /// and [build] to [SemVer].
  ///
  /// It will throws [InvalidSemVerException] if assembled [SemVer] [String]
  /// is invalid.
  factory SemVer(
      {required int major,
      int minor = 0,
      int patch = 0,
      String? preRelease,
      String? build}) {
    SemVer sv = SemVer._(major, minor, patch, preRelease, build);

    if (!validSemVer(sv.toString()))
      throw InvalidSemVerException._(sv.toString());

    return sv;
  }

  /// Gives a [String] of [version] that [SemVer] will resolve it to object.
  ///
  /// It throws [InvalidSemVerException] when given [version] is not valid
  /// [SemVer] format.
  factory SemVer.parse(String version) {
    if (!validSemVer(version)) throw InvalidSemVerException._(version);

    RegExpMatch match = _pattern.firstMatch(version)!;

    return SemVer._(int.parse(match.group(1)!), int.parse(match.group(2)!),
        int.parse(match.group(3)!), match.group(4), match.group(5));
  }

  /// Compare another [SemVer] that to determine is greater, lower or equal by
  /// returning [int] is `1`, `0` and `-1`.
  ///
  /// It follows this order to compare [SemVer]:
  ///
  /// * [major]
  /// * [minor]
  /// * [patch]
  /// * [preRelease] (Opposite ordered)
  /// * [build]
  @override
  int compareTo(SemVer o) {
    // Compare major
    if (major > o.major)
      return 1;
    else if (major < o.major) return -1;

    // Compare minor
    if (minor > o.minor)
      return 1;
    else if (minor < o.minor) return -1;

    // Compare patch
    if (patch > o.patch)
      return 1;
    else if (patch < o.patch) return -1;

    // Compare Pre-release
    if (preRelease != null && o.preRelease != null) {
      int pdiff = preRelease!.compareTo(o.preRelease!);

      if (pdiff != 0) return pdiff < 0 ? -1 : 1;
    } else if (preRelease != null)
      return -1;
    else if (o.preRelease != null) return 1;

    // Compare build
    if (build != null && o.build != null) {
      int bdiff = build!.compareTo(o.build!);

      if (bdiff != 0) return bdiff < 0 ? 1 : -1;
    } else if (build != null)
      return 1;
    else if (o.build != null) return -1;

    // Same semver
    return 0;
  }

  /// Generate hash code for value of [SemVer].
  ///
  /// It generated by hashing [major], [minor], [patch], [preRelease] and
  /// [build] then add their hash code which mod with `65535` and subtract
  /// [major].
  @override
  int get hashCode =>
      hashObjects([major, minor, patch, preRelease, build]) +
      (hashObjects([
                major.hashCode,
                minor.hashCode,
                patch.hashCode,
                preRelease.hashCode,
                build.hashCode
              ]) %
              65535 -
          major);

  /// Compare another [Object] that is [SemVer] with the same values.
  @override
  bool operator ==(Object o) => o is SemVer && compareTo(o) == 0;

  /// Compare another [SemVer] that is greater than [o].
  bool operator >(SemVer o) => compareTo(o) > 0;

  /// Compare another [SemVer] that is lower than [o].
  bool operator <(SemVer o) => compareTo(o) < 0;

  /// Compare another [SemVer] does meet [>] or [==].
  bool operator >=(SemVer o) => compareTo(o) >= 0;

  /// Compare another [SemVer] does meet [<] or [==]/
  bool operator <=(SemVer o) => compareTo(o) <= 0;

  /// Convert [SemVer] to readable [String].
  @override
  String toString() {
    String buf = "${major}.${minor}.${patch}";

    if (preRelease != null) buf += "-${preRelease}";
    if (build != null) buf += "+${build}";

    return buf;
  }

  /// Validate the given [version] is valid [SemVer] format without construction.
  static bool validSemVer(String version) => _pattern.hasMatch(version);

  static RegExp get _pattern => RegExp(
      r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$",
      dotAll: true,
      caseSensitive: true);
}

/// An [Exception] that related to invalid [SemVer] format provided during
/// construction.
@sealed
class InvalidSemVerException implements Exception {
  final String _isv;

  /// Message shown on this exception.
  final String message;

  InvalidSemVerException._(this._isv,
      {this.message = "Applied version is not following semver standard."});

  /// Return actual information of [InvalidSemVerException] with [message] and
  /// invalid [SemVer] [String].
  @override
  String toString() {
    return "InvalidSemVerException: ${message}\n\nApplied versioning: ${_isv}\n\n";
  }
}
